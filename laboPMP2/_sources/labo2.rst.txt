Laboratoire 2
=============

Les notions abordées dans ce laboratoire sont les suivantes:

* Mathématique:

  - Les intégrales curvilignes.

* Physique:

  - La force de Coulomb.
  - La deuxième loi de Newton.
  - L'énergie cinétique et l'énergie potentielle.
  - Le potentiel électrique.
    
Programme 3: Mouvement d'une charge dans un champ électrostatique
-----------------------------------------------------------------

Le programme que vous allez réaliser se base sur celui que vous
avez obtenu à la fin du :doc:`laboratoire 1</labo1>`. Son but est
de simuler le mouvement d'une charge électrique plongée dans un
champ électrostatique (c'est-à-dire le champ électrique créé par
un ensemble de charges immobiles).

Programme de base
~~~~~~~~~~~~~~~~~

La première étape consiste à apporter quelques modifications au
programme 2:

1. Recopier ce programme dans un nouveau fichier ``prog-3.py``.

2. Enlever de ce programme l'ensemble des mécanismes liés à l'affichage
   du champ électrique, qui ne seront pas exploités dans ce projet.

   **Attention:** Ne pas effacer la fonction ``calculer_champ()``,
   qui sera quant à elle réutilisée.

   Concrètement, les fonctions à retirer sont:

   - ``dessiner_vecteur()`` et ``deplacer_pol()``.
   - ``dessiner_champ()`` et ``calculer_couleur()``.

3. Vérifier que le programme fonctionne toujours correctement (en particulier,
   qu'il permet toujours d'ajouter et de retirer des objets chargés).

4. Ajouter un mécanisme permettant de gérer un mobile:

   - Avant d'entrer dans la boucle principale, initialiser à ``False``
     une variable booléenne ``mobile_est_present`` destinée à indiquer
     si le mobile existe ou non.

   - De même, initialiser (à 0) des variables ``mobile_x``, ``mobile_y``,
     ``mobile_vx``, ``mobile_vy`` contenant respectivement
     les composantes x et y de la position et de la vitesse du mobile.

   - Initialiser également (à n'importe quelle valeur) une variable
     ``mobile_charge`` représentant la charge électrique du mobile.

5. Créer une fonction ``dessiner_mobile()`` chargée d'afficher le mobile
   à sa position courante, si ce mobile existe.

   Pour distinguer le mobile des objets chargés, une possibilité est de
   dessiner celui-ci sous la forme d'un cercle (et non d'un disque) de
   couleur rouge si le mobile est chargé positivement, et noire s'il
   est chargé négativement.

   **Notes:**
   
   - En Pygame, l'instruction
     ``pygame.draw.circle(fenetre, couleur, (x, y), r, w)``, avec un
     cinquième paramètre ``w``, dessine un cercle de centre ``(x, y)``,
     de rayon ``r`` et de largeur de trait ``w``. Dans le cas présent,
     une largeur de trait de 4 pixels donne un bon résultat.

   - Ne pas oublier d'appeler ``dessiner_mobile()`` dans la boucle
     principale du programme. Pour tester que cette fonction se comporte
     correctement, on peut temporairement initialiser les variables
     déterminant la position et l'existence du mobile avec des valeurs
     de test.

6. Dans la boucle principale, détecter les évènements de type
   ``pygame.KEYDOWN`` dont le champ ``key`` vaut ``pygame.K_p``
   (touche 'P') ou  ``pygame.K_n`` (touche 'N'). L'appui d'une de
   ces touches doit

   - créer le mobile s'il n'existe pas encore,
   - lui affecter une charge positive ('P') ou négative ('N') de
     :math:`10^{-7}` C, et
   - le positionner à l'endroit où se trouve le pointeur de la souris,
     qui peut être récupéré grâce à l'instruction::
       
       x_souris, y_souris = pygame.mouse.get_pos()
    
   - lui attribuer une vitesse initiale nulle.   

7. Tester votre programme. Celui-ci doit permettre d'ajouter et de
   retirer librement des objets chargés positivement et négativement,
   et de repositionner le mobile à volonté. Voici un exemple d'affichage
   attendu, dans le cas d'un mobile chargé négativement:

    .. figure:: figures/prog-3-screenshot-1.png
      :scale: 33%
      :align: center
      :alt: Affichage du mobile.

      Affichage du mobile.

Mouvement du mobile
~~~~~~~~~~~~~~~~~~~

Lorsqu'une charge électrique :math:`q'` est placée dans un champ électrique,
elle subit une force :math:`\vec{f}` appelée *force de Coulomb*, égale à

  :math:`\vec{f} = q' \vec{E}_{p'}`,

où

  - :math:`p'` est l'endroit où se trouve cette charge,
  - :math:`\vec{E}_{p'}` est la valeur du champ électrique à cet endroit.

(En d'autres termes, on peut voir le champ électrique comme
représentant en tout point de l'espace
la force qui serait subie par une charge unitaire si elle était placée à
cet endroit.)

Pour simuler le mouvement du mobile engendré par cette force, il
suffit d'appliquer la deuxième loi de Newton afin de mettre à jour
répétitivement la vitesse et la position de celui-ci. La procédure est
similaire à celle mise en oeuvre dans les laboratoires
`4 <https:www.montefiore.ulg.ac.be/~boigelot/cours/labmp/tutoriel/labo4.html>`_
,
`5 <https:www.montefiore.ulg.ac.be/~boigelot/cours/labmp/tutoriel/labo5.html>`_
et
`6 <https:www.montefiore.ulg.ac.be/~boigelot/cours/labmp/tutoriel/labo6.html>`_
de la première partie du cours:

1. Dans la boucle principale du programme, appeler une nouvelle fonction
   ``mettre_a_jour_mobile(t)`` pour chaque milliseconde de temps écoulé.
   Le paramètre ``t`` de cette fonction donne l'instant (en secondes)
   de l'étape de simulation courante.

   Plus précisément, cette opération consiste, à chaque itération de
   la boucle principale du programme, à

   - appeler ``pygame.time.get_ticks()`` afin d'obtenir l'instant courant
     ``temps_maintenant``, exprimé en millisecondes.

   - pour chaque valeur de ``t`` depuis l'ancienne valeur de
     ``temps_maintenant`` (c'est-à-dire, celle de l'itération précédente
     de la boucle principale) à ``temps_maintenant - 1``, appeler
     ``mettre_a_jour_mobile(t_secondes)``, où ``t_secondes`` est la
     conversion de ``t`` en secondes.

2. Implémenter la fonction ``mettre_a_jour_mobile()`` afin d'y calculer,
   si le mobile existe, la force qu'il subit, ce qui permet d'en calculer
   l'accélération. Ensuite, mettre à jour la vitesse et la position
   du mobile.

   **Notes:**

   - Le calcul de la force de Coulomb doit bien entendu exploiter le
     calcul du champ électrique déjà implémenté dans la fonction
     ``calculer_champ()``.

   - La masse du mobile, nécessaire au calcul de la deuxième loi
     de Newton, peut être fixée à :math:`10^{-10}` kg.
   
   - Cette opération peut utiliser les mêmes conventions d'unités que
     le programme 2, c'est-à-dire considérer qu'une distance d'un pixel
     dans la fenêtre correspond à un déplacement de 1 m dans la
     simulation.

3. Une difficulté que vous avez peut-être détectée dans
   l'étape précédente est que le champ électrique n'est pas défini partout:
   si vous l'avez correctement implémentée,
   la fonction ``calculer_champ()`` retourne ``None`` aux positions
   très proches d'une charge électrique.

   Une façon simple de résoudre ce problème consiste à faire disparaître
   le mobile (en attribuant la valeur ``False`` à ``mobile_est_present``)
   lorsqu'il entre en collision avec une charge. Ce sera alors à l'utilisateur
   de repositionner le mobile en appuyant sur 'P' ou 'N'.

4. Vérifier soigneusement que votre programme fonctionne, en le testant
   avec des mobiles chargés positivement et négativement.
   
   Ne vous inquiètez pas si le mobile bouge lentement. Dans la configuration
   ci-dessous, il faut normalement une trentaine de secondes pour qu'il
   atteigne le bord droit de la fenêtre. (Des vitesses plus rapides peuvent
   bien sûr être obtenues en créant un plus grand nombre d'objets. Ne pas
   hésiter à expérimenter!)

     .. figure:: figures/prog-3-screenshot-2.png
      :scale: 33%
      :align: center
      :alt: Configuration de test.

      Configuration de test.  

Energie cinétique et énergie potentielle
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Cette étape consiste à ajouter au programme un tableau de bord affichant
à chaque instant l'énergie cinétique et l'énergie potentielle du
mobile. Celles-ci sont définies de la façon suivante:

- Si le mobile se déplace avec une vitesse égale à :math:`\vec{v}`
  et possède la masse :math:`m`, alors son énergie cinétique est égale à
  :math:`\displaystyle\frac{1}{2}m|\vec{v}|^2`.

- L'énergie potentielle électrostatique du mobile correspond au travail
  que celui-ci doit effectuer contre la force de Coulomb pour se déplacer
  d'une position située à l'infini (où, par convention, cette énergie
  potentielle est nulle) vers sa position courante.

  Mathématiquement, ce travail s'exprime sous la forme suivante:

    .. math::
       W = -\int_{\Gamma} \vec{f}.d\vec{u},

  où :math:`\Gamma` est un chemin d'un point situé à l'infini vers la
  position courante du mobile, et :math:`\vec{f}` est la force de Coulomb
  sur les points de ce chemin. Le signe moins exprime le fait que le
  travail s'exerce contre la force.

  Dans le cas de l'énergie potentielle, on peut montrer que cette intégrale
  possède la même valeur quel que soit le chemin :math:`\Gamma` qui est
  emprunté.

  Si le champ électrique est engendré par une seule charge :math:`q`
  située au point :math:`p`, l'énergie potentielle par rapport à ce
  champ d'une charge :math:`q'` située en :math:`p'` peut donc se
  calculer en considérant un chemin :math:`\Gamma` qui suit une ligne
  droite allant de l'infini à :math:`p'`. On obtient alors

    .. math::
       W &= - \int_{+\infty}^r \frac{kqq'}{x^2}dx\\
         &= \int_r^{+\infty} \frac{kqq'}{x^2}dx\\
	 &= \frac{kqq'}{r},

  où :math:`k` est la constante de Coulomb, et :math:`r` est la
  distance séparant :math:`p` de :math:`p'`.

  Pour un champ engendré par plusieurs charges :math:`q_i` situées
  respectivement à la distance :math:`r_i` de :math:`p'`, l'énergie
  potentielle du mobile situé en :math:`p'` correspond à la somme des
  contributions de chaque charge:

    .. math::
       \displaystyle W = \sum_i \frac{kq_iq'}{r_i}.

Vous êtes maintenant prêts à implémenter le tableau de bord.
Voici la marche à suivre:

1. Créer une fonction ``calculer_energie_potentielle(x, y, charge)``
   calculant l'énergie potentielle d'une charge située à un endroit
   ``(x, y)`` donné, en fonction du champ créé par l'ensemble des
   objets fixes.

2. Dans la boucle principale du programme, en exploitant la fonction
   précédente, calculer l'énergie cinétique et l'énergie potentielle
   du mobile (s'il existe), et les mémoriser dans deux variables
   ``energie_cinetique`` et ``energie_potentielle``.

3. En utilisant les mêmes mécanismes que ceux du `programe 8 <https:www.montefiore.ulg.ac.be/~boigelot/cours/labmp/tutoriel/labo5.html#tableau-de-bord>`_ de
   la première partie du cours,
   implémenter un tableau de bord affichant en permanence l'énergie cinétique
   et l'énergie potentielle du mobile, ainsi que leur somme.

   **Note:** Si vos calculs sont corrects et utilisent les constantes
   et les unités qui ont été recommandées par ce tutoriel, les énergies
   en jeu devraient être faibles. Pour qu'elles ne soient pas arrondies
   à zéro, on peut en multiplier la valeur par :math:`10^6` avant de
   les afficher (ce qui revient à les exprimer en *microjoules* plutôt
   qu'en *joules*).

4. Tester votre programme. Le résultat suivant correspond à la situation
   initiale de l'exemple précédent, après une quinzaine de secondes de
   simulation.

     .. figure:: figures/prog-3-screenshot-3.png
      :scale: 33%
      :align: center
      :alt: Tableau de bord.

      Tableau de bord.  

5. Réaliser des expériences! L'objectif est de bien comprendre ce que
   représentent l'énergie cinétique et l'énergie potentielle.  Pourquoi
   leur somme reste-t-elle constante si l'ensemble des charges n'est
   pas modifié? (Si elle ne l'est pas pour votre programme, c'est le
   symptôme d'une erreur!)  Aussi, pouvez-vous donner une interprétation au
   signe de cette somme?

Le potentiel électrique
~~~~~~~~~~~~~~~~~~~~~~~

La dernière partie de de laboratoire est consacrée à la notion de
potentiel électrique. Le potentiel :math:`V` en un point :math:`p'`
est défini comme étant égal à l'énergie potentielle d'une charge
de 1 C placée en :math:`p'` (ou, de façon équivalente, à l'énergie
potentielle d'une charge :math:`q'` divisée par :math:`q'`). On
a donc pour le champ engendré par un ensemble de charges :math:`q_i`:

    .. math::
       \displaystyle V = \sum_i \frac{kq_i}{r_i}.

Procédure:

1. Créer une fonction ``calculer_potentiel(x, y)`` capable de
   calculer le potentiel électrique au point ``(x, y)``. (Il
   faut naturellement essayer d'exploiter le plus possible les
   fonctions déjà implémentées dans votre programme.)

   **Note:** Attention, le mobile génère également un champ électrique!
   Il ne faut pas oublier d'en tenir compte lorsqu'on calcule le
   potentiel. Cela signifie que si le mobile existe, il faut ajouter
   un terme qui lui est associé à l'expression de :math:`V`.

2. A chaque itération de la boucle principale du programme,
   mettre à jour une variable ``potentiel_souris`` chargée de
   retenir la valeur du potentiel électrique à la position
   courante de la souris.

   **Rappel:**: Cette position peut être obtenue en évaluant
   ``pygame.mouse.get_pos()``.

3. Mettre à jour le tableau de bord de façon à afficher la
   valeur courante de ``potentiel_souris``. Attention à bien
   gérer la situation où le potentiel est indéfini (ce qui
   se produit notamment lorsque le pointeur de la souris
   est placé au même endroit qu'une charge).

4. Tester votre programme. Dans cet exemple, le pointeur de
   la souris est placé approximativement au coin supérieur gauche de
   la fenêtre. Les conditions de la simulation sont similaires à
   celles de l'exemple précédent.

   .. figure:: figures/prog-3-screenshot-4.png
      :scale: 33%
      :align: center
      :alt: Affichage du potentiel.

      Affichage du potentiel.   

5. Deposer la version finale de votre programme dans le répertoire
   centralisé des laboratoires, avec le suffixe ``prog-3.py``.
