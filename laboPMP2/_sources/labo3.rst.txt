Laboratoire 3
=============

Les notions abordées dans ce laboratoire sont les suivantes:

* Mathématique:

  - Le reste de la division de nombres réels.

* Physique:

  - Le fonctionnement d'un oscilloscope.
  - La tension et le courant.
  - La loi d'Ohm.
  - La relation entre la tension et le courant d'un condensateur.
  - Le circuit RC.
  - La puissance.

Programme 4: L'oscilloscope
---------------------------

Ce projet consiste à programmer une application simulant un
oscilloscope à quatre canaux. Celle-ci sera ensuite utilisée pour
étudier le comportement de circuits électriques simples.

Principes de fonctionnement
~~~~~~~~~~~~~~~~~~~~~~~~~~~

L'oscilloscope est un appareil permettant de visualiser un signal
électrique (ou plusieurs signaux). Celui que nous allons simuler
fonctionne de la façon suivante:

- Un nombre fixé de fois par secondes (correspondant à la valeur
  d'un paramètre ``images_par_seconde``), le contenu de son écran
  est rafraîchi. On peut fixer initialement
  ``images_par_seconde`` à 25, quitte à devoir le réduire plus
  tard si la charge de calcul du programme devient prohibitive.

- A chaque rafraîchissement de l'écran, l'oscilloscope observe
  le signal pendant une durée égale à un paramètre ``t_trame``.
  Ce paramètre doit donc avoir une valeur inférieure au délai
  séparant deux rafraîchissements successifs de l'écran.

- Pendant un intervalle d'observation du signal, ce dernier
  est échantillonné périodiquement, le nombre d'échantillons
  correspondant à la dimension horizontale de la fenêtre. La
  période d'échantillonnage est notée ``t_echantillons``.

Par exemple, dans le cas où ``images_par_seconde`` vaut 25,
le délai entre deux rafraîchissements est égal
à 40 ms. Si ``t_trame`` vaut 10 ms et si la fenêtre fait 800 pixels
de large, ``t_echantillons`` sera égal à :math:`\frac{10}{800} =
12{,}5` µs. La situation est illustrée ci-dessous, avec les
intervalles d'échantillonnage représentés en couleur.

     
   .. figure:: figures/oscilloscope.png
      :scale: 100%
      :align: center
      :alt: Fonctionnement de l'oscilloscope.

      Fonctionnement de l'oscilloscope.

Programme de base
~~~~~~~~~~~~~~~~~

Vous pouvez partir d'un programme similaire à ceux des
laboratoires précédents, à recopier dans un fichier ``prog-4.py``::

  import math
  import pygame
  import sys

  # Constantes

  BLEUCLAIR = (127, 191, 255)

  # Paramètres

  dimensions_fenetre = (800, 600)  # en pixels
  images_par_seconde = 25
  
  # Initialisation
  
  pygame.init()
  
  fenetre = pygame.display.set_mode(dimensions_fenetre)
  pygame.display.set_caption("Programme 4")
  
  horloge = pygame.time.Clock()
  couleur_fond = BLEUCLAIR

  while True:
      for evenement in pygame.event.get():
          if evenement.type == pygame.QUIT:
              pygame.quit()
              sys.exit()

      fenetre.fill(couleur_fond)    

      pygame.display.flip()
      horloge.tick(images_par_seconde)
  
La première étape consiste à afficher la grille de l'oscilloscope,
qui sert de repère pour estimer la hauteur des signaux
(verticalement) ainsi que les durées (horizontalement).

Pour ce faire, vous devez créer une fonction ``afficher_grille()`` qui
sera appelée dans la boucle principale du programme, et qui est
responsable de
dessiner une grille composée de lignes horizontales et verticales
grises espacées de 100 pixels. Chaque ligne est pointillée, sauf la
ligne horizontale située au centre de la fenêtre, qui fournira une
référence pour situer la valeur nulle des signaux. La longueur de chaque
trait d'un pointillé et l'espacement entre deux traits sont tous deux égaux à 10
pixels.  Le résultat attendu est celui-ci:

   .. figure:: figures/prog-4-screenshot-1.png
      :scale: 50%
      :align: center
      :alt: Affichage de la grille.

      Affichage de la grille.
      
Échantillonnage du signal
~~~~~~~~~~~~~~~~~~~~~~~~~

Nous allons maintenant, à chaque rafraîchissement de l'image, simuler
un générateur de signal de façon à produire des échantillons qui
pourront être affichés. Attention, cette étape n'est pas triviale! La
principale difficulté est que nous allons simuler le générateur **à
chaque instant** (avec une granularité égale à ``t_echantillons``), et
pas seulement pendant les périodes ou le signal est
échantillonné. Cette stratégie nous permettra plus tard d'étudier
le comportement de circuits électriques.

Procédure à suivre:

1. A chaque itération de la boucle principale du programme, appeler
   ``pygame.time.get_ticks()`` pour obtenir l'instant courant, exprimé
   en millisecondes. Transmettre cet instant courant (en tant qu'argument) à une
   nouvelle fonction ``afficher_trame()``, après l'avoir converti
   en **secondes**. (Exprimer toutes les durées dans la même unité
   standard simplifiera les développements.)
   
2. La fonction ``afficher_trame(temps_maintenant)`` est donc chargée
   d'échantillonner le signal (ou les signaux) à partir de
   ``temps_maintenant``, et de le ou les afficher dans la fenêtre. On
   peut l'implémenter de la façon suivante:

   - Effectuer une boucle balayant à l'aide d'une variable ``t``
     l'intervalle de durée ``t_trame`` commençant à l'instant
     ``temps_maintenant``, avec un pas égal à ``t_echantillons``.

     **Rappel:**  ``t_echantillons`` correspond à ``t_trame`` divisé
     par la dimension horizontale de la fenêtre. Cela signifie que cette
     boucle balaye l'ensemble des coordonnées horizontales ``x`` de
     la fenêtre.

   - Pour chaque instant ``t`` exploré par la boucle, appeler une
     fonction ``acquisition(t)`` chargée de simuler la génération et
     l'échantillonnage des signaux à cet instant.

   - Cette fonction ``acquisition()`` sera construite de façon à retourner
     une liste de valeurs (une pour chaque signal). Dans ce projet, nous
     implémentons un oscilloscope à quatre canaux; cette fonction retournera
     donc une liste de quatre valeurs, qui sera récupérée par ``afficher_trame()``
     et placée dans une variable ``signaux``.

   - Dans la boucle interne à ``afficher_trame()``, pour chaque
     composante ``s`` de ``signaux``, appeler une fonction
     ``afficher_signal(x, s, couleur, gain)`` chargée de l'afficher.
     Le paramètre ``x`` correspond à la coordonnée horizontale
     associée à l'instant ``t``, ``s`` est la valeur du signal à
     afficher, ``couleur`` donne la couleur à attribuer à ce signal,
     et ``gain`` est le facteur par lequel il faut multiplier le
     signal avant de l'afficher.

     Dans un premier temps, vous pouvez utiliser un gain de 20 et des
     couleurs bien différentes (par exemple: jaune, cyan, magenta et
     vert) pour chacun des quatre signaux.
            
3. Pour pouvoir tester votre programme, vous pouvez implémenter une première
   version de la fonction ``acquisition(t)`` qui retourne simplement une liste
   constante, par exemple ``[2, 6, 10, -5]``.

4. Implémenter la fonction ``afficher_signal(x, s, couleur, gain)``. Celle-ci
   doit afficher un trait vertical de 10 pixels de hauteur, centré sur le point
   ``(x, y)``, dans la couleur spécifiée. La valeur de ``y`` s'obtient en
   multipliant ``s`` par ``gain``, et en décalant le résultat de telle sorte
   qu'un signal égal à 0 apparaît sur la ligne située au centre de la fenêtre,
   un signal positif au dessus, et un signal négatif en dessous.

5. Tester votre programme. A ce stade, son affichage devrait ressembler à
   celui-ci:

     .. figure:: figures/prog-4-screenshot-2.png
      :scale: 50%
      :align: center
      :alt: Signaux constants.

      Signaux constants.

6. L'étape suivante consiste à remplacer l'implémentation de la
   fonction ``acquisition(t)`` par une version plus réaliste, qui
   simule la génération du signal à tous les instants. Il s'agit de
   l'étape la plus complexe.
   Pour commencer,
   vous allez dans cette fonction calculer la différence
   ``delta_t_acquisition`` entre la valeur actuelle de ``t`` et celle
   de la précédente invocation de cette fonction (que l'on peut noter
   ``t_prec``).

7. Toujours dans la fonction ``acquisition()``, si
   ``delta_t_acquisition`` est négatif, afficher un message d'erreur
   et terminer l'exécution du programme (en exécutant
   ``sys.exit()``). Cette situation indique en effet que les
   paramètres ``t_trame`` et ``images_par_seconde`` de l'oscilloscope
   ne sont pas valides, l'affichage d'une trame nécessitant de revenir
   sur des parties du signal déjà échantillonnées lors de l'affichage
   de la trame précédente.

8. Si ``delta_t_acquisition`` est positif ou nul, effectuer dans
   ``acquisition()`` une boucle explorant tous les instants supérieurs
   ou égaux à ``t_prec + t_echantillons`` et strictement inférieurs à
   ``t``, avec un pas égal à ``t_echantillons``. Pour chaque instant
   ``t_signal`` exploré, appeler une fonction
   ``generer_signaux(t_signal)``.
   
   **Note:** Si ``delta_t_acquisition`` est très petit, il est possible
   qu'il n'y ait aucun instant de ce type.

   Enfin, appeler une dernière fois ``generer_signaux()`` avec ``t`` comme
   argument. La liste ``signaux`` reçue comme résultat est celle qui doit
   être retournée par la fonction ``acquisition()``.

9. Il reste à implémenter la fonction ``generer_signaux(t)``, dont le
   but est de simuler un générateur de quatre signaux, mesurés
   à l'instant ``t``. Tout comme au point précédent, vous allez commencer
   par calculer la différence ``dt`` entre la valeur actuelle de ``t`` et
   celle du précédent appel à ``generer_signaux(t)``.

10. Grâce au mécanisme implémenté au point 8, la valeur de ``dt`` devrait
    toujours être inférieure ou égale à ``t_echantillons`` (vous pouvez
    le vérifier en affichant cette valeur). Cela va permettre d'effectuer
    une simulation *incrémentale* du générateur de signaux: L'état courant
    du simulateur va être mis à jour en calculant l'effet d'un laps de
    temps de durée ``dt``.

11. Pour tester le programme, on va créer un générateur de signaux périodiques.
    Chaque signal :math:`s_i` sera de la forme

    .. math::
       s_i(t) = A_i \cos\left(\frac{2\pi t}{T_i}\right),

    où :math:`A_i` est son amplitude et :math:`T_i` sa période. Pour :math:`i = 1,
    2, 3, 4`, dans la fonction ``generer_signaux()``:

    - On va gérer une variable globale :math:`a_i` initialisée à zéro, et
      représentant l'argument du cosinus.

    - Après avoir calculé ``dt``, on va mettre à jour :math:`a_i` en
      exécutant

      .. math::
         a_i \,\leftarrow\, a_i + \frac{2 \pi \mathit{dt}}{T}.

    - Pour ne pas perdre de précision si la valeur de :math:`a_i` devient grande,
      on va remplacer cette valeur par le reste de sa division par :math:`2 \pi`.

      **Note:** En Python, cette opération s'effectue à l'aide la fonction
      ``math.fmod()``.

    - La fonction ``generer_signaux()`` doit finalement retourner
      une liste contenant :math:`A_i \cos a_i` pour :math:`i = 1,
      2, 3, 4`.

12. Tester soigneusement votre programme. En fixant les paramètres :math:`A_1 = 10`,
    :math:`T_1 = 0{,}009` s, :math:`A_2 = 5`, :math:`T_2 = 0{,}003` s,
    :math:`A_3 = 3`, :math:`T_3 = 0{,}0015` s,
    :math:`A_4 = 2` et :math:`T_4 = 0{,}0045` s, le résultat devrait ressembler
    à celui-ci (toujours avec ``t_trame`` égal à 10 ms):

     .. figure:: figures/prog-4-screenshot-3.png
      :scale: 50%
      :align: center
      :alt: Signaux périodiques.

      Signaux périodiques.

    **Remarques:**

    - Il est normal que l'affichage ne soit pas stable.

    - Si ce programme est trop gourmand en temps CPU pour votre ordinateur
      (sous Linux, la commande ``top`` permet d'estimer sa charge), vous pouvez
      réduire le paramètre ``images_par_seconde``).

Le déclenchement
~~~~~~~~~~~~~~~~

Avec la version actuelle du programme, il n'est pas facile de bien visualiser
les signaux, car leur affichage n'est pas stable: La période de ces signaux
n'étant pas un multiple entier du délai qui sépare deux rafraîchissements, ils
apparaissent avec un décalage variable sur chaque image.

Pour éliminer cet inconvénient, les oscilloscopes disposent d'un mécanisme
de *déclenchement (trigger)*. L'idée consiste, lorsqu'on est prêt à afficher
une nouvelle image, à attendre que le signal de référence dépasse un seuil
donné pour commencer à l'échantillonner. De cette façon, si le signal est
périodique, il sera toujours affiché avec le même décalage sur chaque image.

La marche à suivre pour implémenter ce mécanisme est la suivante:

1. Avant la boucle principale du programme, initialiser une
   variable ``seuil_trigger`` représentant le seuil de déclenchement. Vous
   pouvez lui attribuer une valeur initiale de 5.

2. Modifier la fonction ``afficher_trame()`` de façon à attendre un déclenchement
   avant d'afficher le signal. Le plus simple consiste à programmer une
   nouvelle boucle juste avant celle qui se trouve déjà dans la fonction.
   Dans cette nouvelle boucle, il faut:

   - acquérir les quatre signaux en invoquant ``acquisition(temps_maintenant)``.

   - tester si le premier signal (qui est celui qui sera utilisé pour
     le déclenchement) possède une valeur supérieure ou égale à
     ``seuil_trigger``, et si sa valeur précédente était
     inférieure. Dans ce cas, les conditions sont réunies pour un
     déclenchement, et on sort immédiatement de la
     boucle.

   - incrémenter ``temps_maintenant`` d'une durée égale à
     ``t_echantillons``.
     
   Après un certain nombre d'itérations de cette boucle, si aucun déclenchement
   ne s'est produit, on abandonne l'opération en interrompant la boucle.
   (Cela signifie que l'affichage du signal sera instable comme dans la
   version précédente du programme.) On peut fixer le nombre maximum d'itérations
   à effectuer comme étant égal à la dimension
   horizontale de la fenêtre (ce qui revient à choisir un délai maximum d'attente
   égal à la durée d'une trame).

   **Note:** Dans ce cas, le délai entre deux rafraîchissements doit au moins
   être égal à deux fois la valeur de ``t_trame``.

3. Tester le programme. L'affichage des signaux devrait maintenant
   être stable.  (Un léger tremblement de l'image causé par la
   discrétisation de l'échantillonnage reste possible, comme pour les
   vrais oscilloscopes.)  Au bord gauche de la fenêtre, le premier
   signal (en jaune sur la figure suivante) devrait commencer 100
   pixels plus haut que la ligne médiane, avec une pente positive:

    .. figure:: figures/prog-4-screenshot-4.png
      :scale: 50%
      :align: center
      :alt: Affichage déclenché.

      Affichage déclenché.

Le déclenchement réglable
~~~~~~~~~~~~~~~~~~~~~~~~~

Les vrais oscilloscopes permettent de régler leur seuil de déclenchement
(ainsi que d'autres paramètres influençant celui-ci). Nous allons ajouter
un tel mécanisme dans le programme.

Procédure à suivre:

1. Modifier le code responsable de la gestion des évènements de façon
   à récupérer les évènements de type ``pygame.KEYDOWN``:
  
   - Les frappes sur la flèche haute (``pygame.K_UP``) doivent incrémenter
     ``seuil_trigger`` de 0.2.

   - De même, les frappes sur la flèche basse (``pygame.K_DOWN``) doivent
     décrémenter ``seuil_trigger`` de 0.2.

2. Invoquer, dans la boucle principale du programme, une nouvelle fonction
   ``afficher_trigger()`` chargée d'afficher la valeur courante du seuil
   de déclenchement. Implémenter cette fonction en dessinant un
   trait rouge près du bord gauche de la fenêtre, à la hauteur de déclenchement
   sélectionnée.

   **Note:** Il ne faut pas oublier que les signaux sont multipliés par un
   gain donné avant d'être affichés. Pour que le seuil de déclenchement soit
   affiché correctement, il faut donc le multiplier par le gain choisi pour
   le premier signal (qui est celui qui sert de base au mécanisme de
   déclenchement).

3. Avant d'entrer dans la boucle principale du programme, exécuter l'instruction
   ``pygame.key.set_repeat(10, 10)`` activant la répétition
   des touches du clavier qui restent enfoncées.

4. Tester votre programme. Voici un exemple d'affichage avec déclenchement
   (l'image est donc stable):

    .. figure:: figures/prog-4-screenshot-5.png
      :scale: 50%
      :align: center
      :alt: Déclenchement réglable.

      Déclenchement réglable.

   Lorsque le déclenchement n'a pas eu lieu, les signaux sont quand même
   affichés comme dans l'exemple ci-dessous, mais l'image n'est alors pas stable:

    .. figure:: figures/prog-4-screenshot-6.png
      :scale: 50%
      :align: center
      :alt: Non déclenchement.

      Non déclenchement.

5. Si tout fonctionne comme prévu, déposer le programme dans le répertoire
   centralisé des laboratoires, avec le suffixe ``prog-4.py``.

Programmes 5 et 6: La loi d'Ohm
-------------------------------

L'oscilloscope implémenté dans le programme 4 est un outil très général.
Nous allons à présent l'employer pour étudier le comportement de quelques
circuits électroniques.

Le premier circuit que nous allons considérer est celui-ci:

    .. figure:: figures/circuit-r.png
      :scale: 100%
      :align: center
      :alt: Circuit R.

      Circuit R.

Ce circuit est composé:

- d'un générateur de tension sinusoïdale, d'amplitude 5 V et de fréquence
  111 Hz.

- d'une résistance :math:`R` de 2 :math:`\Omega` connectée aux bornes de ce générateur.

- d'un ampèremètre ('A') mesurant le courant :math:`I` traversant la résistance.

- d'un voltmètre ('V') mesurant la tension :math:`V` aux bornes de la
  résistance.

L'idée consiste à utiliser l'oscilloscope pour observer trois signaux:

- La tension :math:`V`.

- Le courant :math:`I`.

- La puissance :math:`P` dissipée dans la résistance.

**Remarque:** Pour ce circuit, le quatrième signal ne sera pas utilisé;
pour ne pas qu'il s'affiche, on lui attribuera une valeur constante qui sort de
la fenêtre, par exemple 100.

Procédure à suivre:

1. Recopier le programme 4 dans un nouveau programme ``prog-5.py``.

2. Modifier la fonction ``generer_signaux()``:

   - Le premier signal, correspondant à la tension :math:`V`, doit
     être un signal périodique similaire à ceux du programme 4, d'amplitude
     5 V et de fréquence 111 Hz.

   - Le deuxième signal, représentant le courant :math:`I`, peut se calculer
     à partir de :math:`V` grâce à la loi d'Ohm pour la résistance:

       .. math::
          V = R \times I.

   - Le troisième signal, égal à la puissance dans la résistance, vaut

       .. math::
          P = V \times I.

   - Comme discuté précédemment, le quatrième signal prend la valeur constante
     100 de façon à ne pas être visible dans la fenêtre.

3. Essayer votre programme. Le résultat correspond-t-il à ce que vous
   attendiez?

4. Lorsque le programme fonctionne, le déposer dans le répertoire centralisé,
   avec le suffixe ``prog-5.py``.

Dans le programme 6, nous allons simuler une variante du circuit précédent:

    .. figure:: figures/circuit-r-square.png
      :scale: 100%
      :align: center
      :alt: Circuit R avec signal carré.

      Circuit R avec signal carré.

La seule différence est que le générateur produit maintenant un signal
*carré* d'amplitude 5 V et de fréquence 222 Hz. Cela signifie que ce signal
est égal à 5 V pendant la moitié de sa période, et à 0 V pendant l'autre
moitié.

Les modifications à apporter à votre code pour remplacer le signal sinusoïdal
par ce signal carré devraient être minimales. (En particulier, le calcul des
valeurs de :math:`I` et de :math:`P` devraient rester inchangés.) Le programme
fournit-il le résultat attendu? Si oui, déposez-le dans le répertoire centralisé,
avec le suffixe ``prog-6.py``.

Programmes 7 et 8: Circuit RC
-----------------------------

Dans cette dernière étape, nous étudierons un *circuit RC*, faisant intervenir
une résistance et un condensateur. Son schéma est le suivant:

    .. figure:: figures/circuit-rc-square.png
      :scale: 100%
      :align: center
      :alt: Circuit RC.

      Circuit RC.

Nous nous intéressons à quatre signaux:

- La tension :math:`V_1` produite par le générateur, qui prend comme pour le
  programme 6 la forme d'un signal carré de fréquence 222 Hz.

- La tension :math:`V_2` aux bornes du condensateur.

- Le courant :math:`I` traversant la résistance et le condensateur
  (mesuré par l'ampèremètre 'A').

- La puissance :math:`P` échangée avec le condensateur.

Les modifications à apporter au programme 6 sont les suivantes
(effectuez-les dans un nouveau programme ``prog-7.py``). Dans la
fonction ``generer_signaux()``:

- La tension :math:`V_1` est générée de la même façon que la tension
  :math:`V` dans le programme 6.

- La tension :math:`V_2` dépend du niveau de charge du condensateur.
  Le plus simple consiste à représenter cette tension par une nouvelle
  variable globale ``tension_condensateur`` qui sera gérée par la fonction
  ``generer_signaux()``. Initialement, on peut considérer que cette tension
  est nulle (c'est-à-dire, que le condensateur est déchargé au début de la
  simulation).

- A partir de :math:`V_1` et de :math:`V_2`, le courant :math:`I` peut
  se calculer en appliquant la loi d'Ohm aux bornes de la résistance:

    .. math::
      I = \frac{V_1 - V_2}{R}.

- La valeur du courant :math:`I` permet de mettre à jour la tension du
  condensateur, celui-ci se chargeant si :math:`I` est positif et se
  déchargeant s'il est négatif; Pendant le pas de temps :math:`\textit{dt}`
  de la simulation, la tension :math:`V_2` (mémorisée dans
  ``tension_condensateur``) doit évoluer selon la loi:

    .. math::
       V_2 \,\leftarrow\, V_2 + \frac{I\textit{dt}}{C}.

- La puissance échangée avec le condensateur est donnée par le produit

    .. math::
       P = V_2 \times I.

**Note importante:** Pour que les signaux 3 et 4 soient visibles,
vous devez modifier le gain qui leur est appliqué dans le
programme. Pour les valeurs proposées des composants, un gain de
20000 pour ces deux signaux produit un bon résultat.
       
Après avoir implémenté ces modifications dans votre programme,
qu'observez-vous? N'hésitez pas à expérimenter en modifiant
la valeur de R et de C. Les signaux obtenus correspondent-ils à ce que
prévoit la théorie? 

Une fois que votre programme est au point,
déposez-le dans le répertoire des laboratoires, avec le suffixe
``prog-7.py``.

Il reste à présent à simuler le même circuit, mais avec un générateur
sinusoïdal:

    .. figure:: figures/circuit-rc-sin.png
      :scale: 100%
      :align: center
      :alt: Circuit RC avec signal sinusoïdal.

      Circuit RC avec signal sinusoïdal.

Les modifications à apporter au programme sont simples. Cette fois,
avant de les effectuer et de tester l'application, essayez de dessiner
sur une feuille de papier la forme des quatre signaux qui devraient être
obtenus. Comparez ensuite vos prédictions avec le résultat de l'expérience.
Déposez enfin votre programme dans le répertoire centralisé, avec le
suffixe ``prog-8.py``.
