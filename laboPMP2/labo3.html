
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="fr">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Laboratoire 3 &#8212; documentation Laboratoires de programmation mathématique et physique 2 0.1</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Recherche" href="search.html" />
    <link rel="next" title="Laboratoire 4" href="labo4.html" />
    <link rel="prev" title="Laboratoire 2" href="labo2.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Index général"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="labo4.html" title="Laboratoire 4"
             accesskey="N">suivant</a> |</li>
        <li class="right" >
          <a href="labo2.html" title="Laboratoire 2"
             accesskey="P">précédent</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">documentation Laboratoires de programmation mathématique et physique 2 0.1</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="laboratoire-3">
<h1>Laboratoire 3<a class="headerlink" href="#laboratoire-3" title="Lien permanent vers ce titre">¶</a></h1>
<p>Les notions abordées dans ce laboratoire sont les suivantes:</p>
<ul class="simple">
<li>Mathématique:<ul>
<li>Le reste de la division de nombres réels.</li>
</ul>
</li>
<li>Physique:<ul>
<li>Le fonctionnement d’un oscilloscope.</li>
<li>La tension et le courant.</li>
<li>La loi d’Ohm.</li>
<li>La relation entre la tension et le courant d’un condensateur.</li>
<li>Le circuit RC.</li>
<li>La puissance.</li>
</ul>
</li>
</ul>
<div class="section" id="programme-4-l-oscilloscope">
<h2>Programme 4: L’oscilloscope<a class="headerlink" href="#programme-4-l-oscilloscope" title="Lien permanent vers ce titre">¶</a></h2>
<p>Ce projet consiste à programmer une application simulant un
oscilloscope à quatre canaux. Celle-ci sera ensuite utilisée pour
étudier le comportement de circuits électriques simples.</p>
<div class="section" id="principes-de-fonctionnement">
<h3>Principes de fonctionnement<a class="headerlink" href="#principes-de-fonctionnement" title="Lien permanent vers ce titre">¶</a></h3>
<p>L’oscilloscope est un appareil permettant de visualiser un signal
électrique (ou plusieurs signaux). Celui que nous allons simuler
fonctionne de la façon suivante:</p>
<ul class="simple">
<li>Un nombre fixé de fois par secondes (correspondant à la valeur
d’un paramètre <code class="docutils literal"><span class="pre">images_par_seconde</span></code>), le contenu de son écran
est rafraîchi. On peut fixer initialement
<code class="docutils literal"><span class="pre">images_par_seconde</span></code> à 25, quitte à devoir le réduire plus
tard si la charge de calcul du programme devient prohibitive.</li>
<li>A chaque rafraîchissement de l’écran, l’oscilloscope observe
le signal pendant une durée égale à un paramètre <code class="docutils literal"><span class="pre">t_trame</span></code>.
Ce paramètre doit donc avoir une valeur inférieure au délai
séparant deux rafraîchissements successifs de l’écran.</li>
<li>Pendant un intervalle d’observation du signal, ce dernier
est échantillonné périodiquement, le nombre d’échantillons
correspondant à la dimension horizontale de la fenêtre. La
période d’échantillonnage est notée <code class="docutils literal"><span class="pre">t_echantillons</span></code>.</li>
</ul>
<p>Par exemple, dans le cas où <code class="docutils literal"><span class="pre">images_par_seconde</span></code> vaut 25,
le délai entre deux rafraîchissements est égal
à 40 ms. Si <code class="docutils literal"><span class="pre">t_trame</span></code> vaut 10 ms et si la fenêtre fait 800 pixels
de large, <code class="docutils literal"><span class="pre">t_echantillons</span></code> sera égal à <span class="math">\(\frac{10}{800} =
12{,}5\)</span> µs. La situation est illustrée ci-dessous, avec les
intervalles d’échantillonnage représentés en couleur.</p>
<blockquote>
<div><div class="figure align-center" id="id1">
<a class="reference internal image-reference" href="_images/oscilloscope.png"><img alt="Fonctionnement de l'oscilloscope." src="_images/oscilloscope.png" style="width: 699.0px; height: 229.0px;" /></a>
<p class="caption"><span class="caption-text">Fonctionnement de l’oscilloscope.</span></p>
</div>
</div></blockquote>
</div>
<div class="section" id="programme-de-base">
<h3>Programme de base<a class="headerlink" href="#programme-de-base" title="Lien permanent vers ce titre">¶</a></h3>
<p>Vous pouvez partir d’un programme similaire à ceux des
laboratoires précédents, à recopier dans un fichier <code class="docutils literal"><span class="pre">prog-4.py</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># Constantes</span>

<span class="n">BLEUCLAIR</span> <span class="o">=</span> <span class="p">(</span><span class="mi">127</span><span class="p">,</span> <span class="mi">191</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span>

<span class="c1"># Paramètres</span>

<span class="n">dimensions_fenetre</span> <span class="o">=</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">)</span>  <span class="c1"># en pixels</span>
<span class="n">images_par_seconde</span> <span class="o">=</span> <span class="mi">25</span>

<span class="c1"># Initialisation</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="n">fenetre</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">(</span><span class="n">dimensions_fenetre</span><span class="p">)</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_caption</span><span class="p">(</span><span class="s2">&quot;Programme 4&quot;</span><span class="p">)</span>

<span class="n">horloge</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">Clock</span><span class="p">()</span>
<span class="n">couleur_fond</span> <span class="o">=</span> <span class="n">BLEUCLAIR</span>

<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">evenement</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">evenement</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span><span class="p">:</span>
            <span class="n">pygame</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>

    <span class="n">fenetre</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">couleur_fond</span><span class="p">)</span>

    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span>
    <span class="n">horloge</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">images_par_seconde</span><span class="p">)</span>
</pre></div>
</div>
<p>La première étape consiste à afficher la grille de l’oscilloscope,
qui sert de repère pour estimer la hauteur des signaux
(verticalement) ainsi que les durées (horizontalement).</p>
<p>Pour ce faire, vous devez créer une fonction <code class="docutils literal"><span class="pre">afficher_grille()</span></code> qui
sera appelée dans la boucle principale du programme, et qui est
responsable de
dessiner une grille composée de lignes horizontales et verticales
grises espacées de 100 pixels. Chaque ligne est pointillée, sauf la
ligne horizontale située au centre de la fenêtre, qui fournira une
référence pour situer la valeur nulle des signaux. La longueur de chaque
trait d’un pointillé et l’espacement entre deux traits sont tous deux égaux à 10
pixels.  Le résultat attendu est celui-ci:</p>
<blockquote>
<div><div class="figure align-center" id="id2">
<a class="reference internal image-reference" href="_images/prog-4-screenshot-1.png"><img alt="Affichage de la grille." src="_images/prog-4-screenshot-1.png" style="width: 401.0px; height: 314.0px;" /></a>
<p class="caption"><span class="caption-text">Affichage de la grille.</span></p>
</div>
</div></blockquote>
</div>
<div class="section" id="echantillonnage-du-signal">
<h3>Échantillonnage du signal<a class="headerlink" href="#echantillonnage-du-signal" title="Lien permanent vers ce titre">¶</a></h3>
<p>Nous allons maintenant, à chaque rafraîchissement de l’image, simuler
un générateur de signal de façon à produire des échantillons qui
pourront être affichés. Attention, cette étape n’est pas triviale! La
principale difficulté est que nous allons simuler le générateur <strong>à
chaque instant</strong> (avec une granularité égale à <code class="docutils literal"><span class="pre">t_echantillons</span></code>), et
pas seulement pendant les périodes ou le signal est
échantillonné. Cette stratégie nous permettra plus tard d’étudier
le comportement de circuits électriques.</p>
<p>Procédure à suivre:</p>
<ol class="arabic">
<li><p class="first">A chaque itération de la boucle principale du programme, appeler
<code class="docutils literal"><span class="pre">pygame.time.get_ticks()</span></code> pour obtenir l’instant courant, exprimé
en millisecondes. Transmettre cet instant courant (en tant qu’argument) à une
nouvelle fonction <code class="docutils literal"><span class="pre">afficher_trame()</span></code>, après l’avoir converti
en <strong>secondes</strong>. (Exprimer toutes les durées dans la même unité
standard simplifiera les développements.)</p>
</li>
<li><p class="first">La fonction <code class="docutils literal"><span class="pre">afficher_trame(temps_maintenant)</span></code> est donc chargée
d’échantillonner le signal (ou les signaux) à partir de
<code class="docutils literal"><span class="pre">temps_maintenant</span></code>, et de le ou les afficher dans la fenêtre. On
peut l’implémenter de la façon suivante:</p>
<ul>
<li><p class="first">Effectuer une boucle balayant à l’aide d’une variable <code class="docutils literal"><span class="pre">t</span></code>
l’intervalle de durée <code class="docutils literal"><span class="pre">t_trame</span></code> commençant à l’instant
<code class="docutils literal"><span class="pre">temps_maintenant</span></code>, avec un pas égal à <code class="docutils literal"><span class="pre">t_echantillons</span></code>.</p>
<p><strong>Rappel:</strong>  <code class="docutils literal"><span class="pre">t_echantillons</span></code> correspond à <code class="docutils literal"><span class="pre">t_trame</span></code> divisé
par la dimension horizontale de la fenêtre. Cela signifie que cette
boucle balaye l’ensemble des coordonnées horizontales <code class="docutils literal"><span class="pre">x</span></code> de
la fenêtre.</p>
</li>
<li><p class="first">Pour chaque instant <code class="docutils literal"><span class="pre">t</span></code> exploré par la boucle, appeler une
fonction <code class="docutils literal"><span class="pre">acquisition(t)</span></code> chargée de simuler la génération et
l’échantillonnage des signaux à cet instant.</p>
</li>
<li><p class="first">Cette fonction <code class="docutils literal"><span class="pre">acquisition()</span></code> sera construite de façon à retourner
une liste de valeurs (une pour chaque signal). Dans ce projet, nous
implémentons un oscilloscope à quatre canaux; cette fonction retournera
donc une liste de quatre valeurs, qui sera récupérée par <code class="docutils literal"><span class="pre">afficher_trame()</span></code>
et placée dans une variable <code class="docutils literal"><span class="pre">signaux</span></code>.</p>
</li>
<li><p class="first">Dans la boucle interne à <code class="docutils literal"><span class="pre">afficher_trame()</span></code>, pour chaque
composante <code class="docutils literal"><span class="pre">s</span></code> de <code class="docutils literal"><span class="pre">signaux</span></code>, appeler une fonction
<code class="docutils literal"><span class="pre">afficher_signal(x,</span> <span class="pre">s,</span> <span class="pre">couleur,</span> <span class="pre">gain)</span></code> chargée de l’afficher.
Le paramètre <code class="docutils literal"><span class="pre">x</span></code> correspond à la coordonnée horizontale
associée à l’instant <code class="docutils literal"><span class="pre">t</span></code>, <code class="docutils literal"><span class="pre">s</span></code> est la valeur du signal à
afficher, <code class="docutils literal"><span class="pre">couleur</span></code> donne la couleur à attribuer à ce signal,
et <code class="docutils literal"><span class="pre">gain</span></code> est le facteur par lequel il faut multiplier le
signal avant de l’afficher.</p>
<p>Dans un premier temps, vous pouvez utiliser un gain de 20 et des
couleurs bien différentes (par exemple: jaune, cyan, magenta et
vert) pour chacun des quatre signaux.</p>
</li>
</ul>
</li>
<li><p class="first">Pour pouvoir tester votre programme, vous pouvez implémenter une première
version de la fonction <code class="docutils literal"><span class="pre">acquisition(t)</span></code> qui retourne simplement une liste
constante, par exemple <code class="docutils literal"><span class="pre">[2,</span> <span class="pre">6,</span> <span class="pre">10,</span> <span class="pre">-5]</span></code>.</p>
</li>
<li><p class="first">Implémenter la fonction <code class="docutils literal"><span class="pre">afficher_signal(x,</span> <span class="pre">s,</span> <span class="pre">couleur,</span> <span class="pre">gain)</span></code>. Celle-ci
doit afficher un trait vertical de 10 pixels de hauteur, centré sur le point
<code class="docutils literal"><span class="pre">(x,</span> <span class="pre">y)</span></code>, dans la couleur spécifiée. La valeur de <code class="docutils literal"><span class="pre">y</span></code> s’obtient en
multipliant <code class="docutils literal"><span class="pre">s</span></code> par <code class="docutils literal"><span class="pre">gain</span></code>, et en décalant le résultat de telle sorte
qu’un signal égal à 0 apparaît sur la ligne située au centre de la fenêtre,
un signal positif au dessus, et un signal négatif en dessous.</p>
</li>
<li><p class="first">Tester votre programme. A ce stade, son affichage devrait ressembler à
celui-ci:</p>
<blockquote>
<div><div class="figure align-center" id="id3">
<a class="reference internal image-reference" href="_images/prog-4-screenshot-2.png"><img alt="Signaux constants." src="_images/prog-4-screenshot-2.png" style="width: 401.0px; height: 314.0px;" /></a>
<p class="caption"><span class="caption-text">Signaux constants.</span></p>
</div>
</div></blockquote>
</li>
<li><p class="first">L’étape suivante consiste à remplacer l’implémentation de la
fonction <code class="docutils literal"><span class="pre">acquisition(t)</span></code> par une version plus réaliste, qui
simule la génération du signal à tous les instants. Il s’agit de
l’étape la plus complexe.
Pour commencer,
vous allez dans cette fonction calculer la différence
<code class="docutils literal"><span class="pre">delta_t_acquisition</span></code> entre la valeur actuelle de <code class="docutils literal"><span class="pre">t</span></code> et celle
de la précédente invocation de cette fonction (que l’on peut noter
<code class="docutils literal"><span class="pre">t_prec</span></code>).</p>
</li>
<li><p class="first">Toujours dans la fonction <code class="docutils literal"><span class="pre">acquisition()</span></code>, si
<code class="docutils literal"><span class="pre">delta_t_acquisition</span></code> est négatif, afficher un message d’erreur
et terminer l’exécution du programme (en exécutant
<code class="docutils literal"><span class="pre">sys.exit()</span></code>). Cette situation indique en effet que les
paramètres <code class="docutils literal"><span class="pre">t_trame</span></code> et <code class="docutils literal"><span class="pre">images_par_seconde</span></code> de l’oscilloscope
ne sont pas valides, l’affichage d’une trame nécessitant de revenir
sur des parties du signal déjà échantillonnées lors de l’affichage
de la trame précédente.</p>
</li>
<li><p class="first">Si <code class="docutils literal"><span class="pre">delta_t_acquisition</span></code> est positif ou nul, effectuer dans
<code class="docutils literal"><span class="pre">acquisition()</span></code> une boucle explorant tous les instants supérieurs
ou égaux à <code class="docutils literal"><span class="pre">t_prec</span> <span class="pre">+</span> <span class="pre">t_echantillons</span></code> et strictement inférieurs à
<code class="docutils literal"><span class="pre">t</span></code>, avec un pas égal à <code class="docutils literal"><span class="pre">t_echantillons</span></code>. Pour chaque instant
<code class="docutils literal"><span class="pre">t_signal</span></code> exploré, appeler une fonction
<code class="docutils literal"><span class="pre">generer_signaux(t_signal)</span></code>.</p>
<p><strong>Note:</strong> Si <code class="docutils literal"><span class="pre">delta_t_acquisition</span></code> est très petit, il est possible
qu’il n’y ait aucun instant de ce type.</p>
<p>Enfin, appeler une dernière fois <code class="docutils literal"><span class="pre">generer_signaux()</span></code> avec <code class="docutils literal"><span class="pre">t</span></code> comme
argument. La liste <code class="docutils literal"><span class="pre">signaux</span></code> reçue comme résultat est celle qui doit
être retournée par la fonction <code class="docutils literal"><span class="pre">acquisition()</span></code>.</p>
</li>
<li><p class="first">Il reste à implémenter la fonction <code class="docutils literal"><span class="pre">generer_signaux(t)</span></code>, dont le
but est de simuler un générateur de quatre signaux, mesurés
à l’instant <code class="docutils literal"><span class="pre">t</span></code>. Tout comme au point précédent, vous allez commencer
par calculer la différence <code class="docutils literal"><span class="pre">dt</span></code> entre la valeur actuelle de <code class="docutils literal"><span class="pre">t</span></code> et
celle du précédent appel à <code class="docutils literal"><span class="pre">generer_signaux(t)</span></code>.</p>
</li>
<li><p class="first">Grâce au mécanisme implémenté au point 8, la valeur de <code class="docutils literal"><span class="pre">dt</span></code> devrait
toujours être inférieure ou égale à <code class="docutils literal"><span class="pre">t_echantillons</span></code> (vous pouvez
le vérifier en affichant cette valeur). Cela va permettre d’effectuer
une simulation <em>incrémentale</em> du générateur de signaux: L’état courant
du simulateur va être mis à jour en calculant l’effet d’un laps de
temps de durée <code class="docutils literal"><span class="pre">dt</span></code>.</p>
</li>
<li><p class="first">Pour tester le programme, on va créer un générateur de signaux périodiques.
Chaque signal <span class="math">\(s_i\)</span> sera de la forme</p>
<div class="math">
\[s_i(t) = A_i \cos\left(\frac{2\pi t}{T_i}\right),\]</div>
<p>où <span class="math">\(A_i\)</span> est son amplitude et <span class="math">\(T_i\)</span> sa période. Pour <span class="math">\(i = 1,
2, 3, 4\)</span>, dans la fonction <code class="docutils literal"><span class="pre">generer_signaux()</span></code>:</p>
<ul>
<li><p class="first">On va gérer une variable globale <span class="math">\(a_i\)</span> initialisée à zéro, et
représentant l’argument du cosinus.</p>
</li>
<li><p class="first">Après avoir calculé <code class="docutils literal"><span class="pre">dt</span></code>, on va mettre à jour <span class="math">\(a_i\)</span> en
exécutant</p>
<div class="math">
\[a_i \,\leftarrow\, a_i + \frac{2 \pi \mathit{dt}}{T}.\]</div>
</li>
<li><p class="first">Pour ne pas perdre de précision si la valeur de <span class="math">\(a_i\)</span> devient grande,
on va remplacer cette valeur par le reste de sa division par <span class="math">\(2 \pi\)</span>.</p>
<p><strong>Note:</strong> En Python, cette opération s’effectue à l’aide la fonction
<code class="docutils literal"><span class="pre">math.fmod()</span></code>.</p>
</li>
<li><p class="first">La fonction <code class="docutils literal"><span class="pre">generer_signaux()</span></code> doit finalement retourner
une liste contenant <span class="math">\(A_i \cos a_i\)</span> pour <span class="math">\(i = 1,
2, 3, 4\)</span>.</p>
</li>
</ul>
</li>
<li><p class="first">Tester soigneusement votre programme. En fixant les paramètres <span class="math">\(A_1 = 10\)</span>,
<span class="math">\(T_1 = 0{,}009\)</span> s, <span class="math">\(A_2 = 5\)</span>, <span class="math">\(T_2 = 0{,}003\)</span> s,
<span class="math">\(A_3 = 3\)</span>, <span class="math">\(T_3 = 0{,}0015\)</span> s,
<span class="math">\(A_4 = 2\)</span> et <span class="math">\(T_4 = 0{,}0045\)</span> s, le résultat devrait ressembler
à celui-ci (toujours avec <code class="docutils literal"><span class="pre">t_trame</span></code> égal à 10 ms):</p>
<blockquote>
<div><div class="figure align-center" id="id4">
<a class="reference internal image-reference" href="_images/prog-4-screenshot-3.png"><img alt="Signaux périodiques." src="_images/prog-4-screenshot-3.png" style="width: 401.0px; height: 314.0px;" /></a>
<p class="caption"><span class="caption-text">Signaux périodiques.</span></p>
</div>
</div></blockquote>
<p><strong>Remarques:</strong></p>
<ul class="simple">
<li>Il est normal que l’affichage ne soit pas stable.</li>
<li>Si ce programme est trop gourmand en temps CPU pour votre ordinateur
(sous Linux, la commande <code class="docutils literal"><span class="pre">top</span></code> permet d’estimer sa charge), vous pouvez
réduire le paramètre <code class="docutils literal"><span class="pre">images_par_seconde</span></code>).</li>
</ul>
</li>
</ol>
</div>
<div class="section" id="le-declenchement">
<h3>Le déclenchement<a class="headerlink" href="#le-declenchement" title="Lien permanent vers ce titre">¶</a></h3>
<p>Avec la version actuelle du programme, il n’est pas facile de bien visualiser
les signaux, car leur affichage n’est pas stable: La période de ces signaux
n’étant pas un multiple entier du délai qui sépare deux rafraîchissements, ils
apparaissent avec un décalage variable sur chaque image.</p>
<p>Pour éliminer cet inconvénient, les oscilloscopes disposent d’un mécanisme
de <em>déclenchement (trigger)</em>. L’idée consiste, lorsqu’on est prêt à afficher
une nouvelle image, à attendre que le signal de référence dépasse un seuil
donné pour commencer à l’échantillonner. De cette façon, si le signal est
périodique, il sera toujours affiché avec le même décalage sur chaque image.</p>
<p>La marche à suivre pour implémenter ce mécanisme est la suivante:</p>
<ol class="arabic">
<li><p class="first">Avant la boucle principale du programme, initialiser une
variable <code class="docutils literal"><span class="pre">seuil_trigger</span></code> représentant le seuil de déclenchement. Vous
pouvez lui attribuer une valeur initiale de 5.</p>
</li>
<li><p class="first">Modifier la fonction <code class="docutils literal"><span class="pre">afficher_trame()</span></code> de façon à attendre un déclenchement
avant d’afficher le signal. Le plus simple consiste à programmer une
nouvelle boucle juste avant celle qui se trouve déjà dans la fonction.
Dans cette nouvelle boucle, il faut:</p>
<ul class="simple">
<li>acquérir les quatre signaux en invoquant <code class="docutils literal"><span class="pre">acquisition(temps_maintenant)</span></code>.</li>
<li>tester si le premier signal (qui est celui qui sera utilisé pour
le déclenchement) possède une valeur supérieure ou égale à
<code class="docutils literal"><span class="pre">seuil_trigger</span></code>, et si sa valeur précédente était
inférieure. Dans ce cas, les conditions sont réunies pour un
déclenchement, et on sort immédiatement de la
boucle.</li>
<li>incrémenter <code class="docutils literal"><span class="pre">temps_maintenant</span></code> d’une durée égale à
<code class="docutils literal"><span class="pre">t_echantillons</span></code>.</li>
</ul>
<p>Après un certain nombre d’itérations de cette boucle, si aucun déclenchement
ne s’est produit, on abandonne l’opération en interrompant la boucle.
(Cela signifie que l’affichage du signal sera instable comme dans la
version précédente du programme.) On peut fixer le nombre maximum d’itérations
à effectuer comme étant égal à la dimension
horizontale de la fenêtre (ce qui revient à choisir un délai maximum d’attente
égal à la durée d’une trame).</p>
<p><strong>Note:</strong> Dans ce cas, le délai entre deux rafraîchissements doit au moins
être égal à deux fois la valeur de <code class="docutils literal"><span class="pre">t_trame</span></code>.</p>
</li>
<li><p class="first">Tester le programme. L’affichage des signaux devrait maintenant
être stable.  (Un léger tremblement de l’image causé par la
discrétisation de l’échantillonnage reste possible, comme pour les
vrais oscilloscopes.)  Au bord gauche de la fenêtre, le premier
signal (en jaune sur la figure suivante) devrait commencer 100
pixels plus haut que la ligne médiane, avec une pente positive:</p>
<blockquote>
<div><div class="figure align-center" id="id5">
<a class="reference internal image-reference" href="_images/prog-4-screenshot-4.png"><img alt="Affichage déclenché." src="_images/prog-4-screenshot-4.png" style="width: 401.0px; height: 314.0px;" /></a>
<p class="caption"><span class="caption-text">Affichage déclenché.</span></p>
</div>
</div></blockquote>
</li>
</ol>
</div>
<div class="section" id="le-declenchement-reglable">
<h3>Le déclenchement réglable<a class="headerlink" href="#le-declenchement-reglable" title="Lien permanent vers ce titre">¶</a></h3>
<p>Les vrais oscilloscopes permettent de régler leur seuil de déclenchement
(ainsi que d’autres paramètres influençant celui-ci). Nous allons ajouter
un tel mécanisme dans le programme.</p>
<p>Procédure à suivre:</p>
<ol class="arabic">
<li><p class="first">Modifier le code responsable de la gestion des évènements de façon
à récupérer les évènements de type <code class="docutils literal"><span class="pre">pygame.KEYDOWN</span></code>:</p>
<ul class="simple">
<li>Les frappes sur la flèche haute (<code class="docutils literal"><span class="pre">pygame.K_UP</span></code>) doivent incrémenter
<code class="docutils literal"><span class="pre">seuil_trigger</span></code> de 0.2.</li>
<li>De même, les frappes sur la flèche basse (<code class="docutils literal"><span class="pre">pygame.K_DOWN</span></code>) doivent
décrémenter <code class="docutils literal"><span class="pre">seuil_trigger</span></code> de 0.2.</li>
</ul>
</li>
<li><p class="first">Invoquer, dans la boucle principale du programme, une nouvelle fonction
<code class="docutils literal"><span class="pre">afficher_trigger()</span></code> chargée d’afficher la valeur courante du seuil
de déclenchement. Implémenter cette fonction en dessinant un
trait rouge près du bord gauche de la fenêtre, à la hauteur de déclenchement
sélectionnée.</p>
<p><strong>Note:</strong> Il ne faut pas oublier que les signaux sont multipliés par un
gain donné avant d’être affichés. Pour que le seuil de déclenchement soit
affiché correctement, il faut donc le multiplier par le gain choisi pour
le premier signal (qui est celui qui sert de base au mécanisme de
déclenchement).</p>
</li>
<li><p class="first">Avant d’entrer dans la boucle principale du programme, exécuter l’instruction
<code class="docutils literal"><span class="pre">pygame.key.set_repeat(10,</span> <span class="pre">10)</span></code> activant la répétition
des touches du clavier qui restent enfoncées.</p>
</li>
<li><p class="first">Tester votre programme. Voici un exemple d’affichage avec déclenchement
(l’image est donc stable):</p>
<blockquote>
<div><div class="figure align-center" id="id6">
<a class="reference internal image-reference" href="_images/prog-4-screenshot-5.png"><img alt="Déclenchement réglable." src="_images/prog-4-screenshot-5.png" style="width: 401.0px; height: 314.0px;" /></a>
<p class="caption"><span class="caption-text">Déclenchement réglable.</span></p>
</div>
</div></blockquote>
<p>Lorsque le déclenchement n’a pas eu lieu, les signaux sont quand même
affichés comme dans l’exemple ci-dessous, mais l’image n’est alors pas stable:</p>
<blockquote>
<div><div class="figure align-center" id="id7">
<a class="reference internal image-reference" href="_images/prog-4-screenshot-6.png"><img alt="Non déclenchement." src="_images/prog-4-screenshot-6.png" style="width: 401.0px; height: 314.0px;" /></a>
<p class="caption"><span class="caption-text">Non déclenchement.</span></p>
</div>
</div></blockquote>
</li>
<li><p class="first">Si tout fonctionne comme prévu, déposer le programme dans le répertoire
centralisé des laboratoires, avec le suffixe <code class="docutils literal"><span class="pre">prog-4.py</span></code>.</p>
</li>
</ol>
</div>
</div>
<div class="section" id="programmes-5-et-6-la-loi-d-ohm">
<h2>Programmes 5 et 6: La loi d’Ohm<a class="headerlink" href="#programmes-5-et-6-la-loi-d-ohm" title="Lien permanent vers ce titre">¶</a></h2>
<p>L’oscilloscope implémenté dans le programme 4 est un outil très général.
Nous allons à présent l’employer pour étudier le comportement de quelques
circuits électroniques.</p>
<p>Le premier circuit que nous allons considérer est celui-ci:</p>
<blockquote>
<div><div class="figure align-center" id="id8">
<a class="reference internal image-reference" href="_images/circuit-r.png"><img alt="Circuit R." src="_images/circuit-r.png" style="width: 490.0px; height: 259.0px;" /></a>
<p class="caption"><span class="caption-text">Circuit R.</span></p>
</div>
</div></blockquote>
<p>Ce circuit est composé:</p>
<ul class="simple">
<li>d’un générateur de tension sinusoïdale, d’amplitude 5 V et de fréquence
111 Hz.</li>
<li>d’une résistance <span class="math">\(R\)</span> de 2 <span class="math">\(\Omega\)</span> connectée aux bornes de ce générateur.</li>
<li>d’un ampèremètre (“A”) mesurant le courant <span class="math">\(I\)</span> traversant la résistance.</li>
<li>d’un voltmètre (“V”) mesurant la tension <span class="math">\(V\)</span> aux bornes de la
résistance.</li>
</ul>
<p>L’idée consiste à utiliser l’oscilloscope pour observer trois signaux:</p>
<ul class="simple">
<li>La tension <span class="math">\(V\)</span>.</li>
<li>Le courant <span class="math">\(I\)</span>.</li>
<li>La puissance <span class="math">\(P\)</span> dissipée dans la résistance.</li>
</ul>
<p><strong>Remarque:</strong> Pour ce circuit, le quatrième signal ne sera pas utilisé;
pour ne pas qu’il s’affiche, on lui attribuera une valeur constante qui sort de
la fenêtre, par exemple 100.</p>
<p>Procédure à suivre:</p>
<ol class="arabic">
<li><p class="first">Recopier le programme 4 dans un nouveau programme <code class="docutils literal"><span class="pre">prog-5.py</span></code>.</p>
</li>
<li><p class="first">Modifier la fonction <code class="docutils literal"><span class="pre">generer_signaux()</span></code>:</p>
<ul>
<li><p class="first">Le premier signal, correspondant à la tension <span class="math">\(V\)</span>, doit
être un signal périodique similaire à ceux du programme 4, d’amplitude
5 V et de fréquence 111 Hz.</p>
</li>
<li><p class="first">Le deuxième signal, représentant le courant <span class="math">\(I\)</span>, peut se calculer
à partir de <span class="math">\(V\)</span> grâce à la loi d’Ohm pour la résistance:</p>
<blockquote>
<div><div class="math">
\[V = R \times I.\]</div>
</div></blockquote>
</li>
<li><p class="first">Le troisième signal, égal à la puissance dans la résistance, vaut</p>
<blockquote>
<div><div class="math">
\[P = V \times I.\]</div>
</div></blockquote>
</li>
<li><p class="first">Comme discuté précédemment, le quatrième signal prend la valeur constante
100 de façon à ne pas être visible dans la fenêtre.</p>
</li>
</ul>
</li>
<li><p class="first">Essayer votre programme. Le résultat correspond-t-il à ce que vous
attendiez?</p>
</li>
<li><p class="first">Lorsque le programme fonctionne, le déposer dans le répertoire centralisé,
avec le suffixe <code class="docutils literal"><span class="pre">prog-5.py</span></code>.</p>
</li>
</ol>
<p>Dans le programme 6, nous allons simuler une variante du circuit précédent:</p>
<blockquote>
<div><div class="figure align-center" id="id9">
<a class="reference internal image-reference" href="_images/circuit-r-square.png"><img alt="Circuit R avec signal carré." src="_images/circuit-r-square.png" style="width: 490.0px; height: 259.0px;" /></a>
<p class="caption"><span class="caption-text">Circuit R avec signal carré.</span></p>
</div>
</div></blockquote>
<p>La seule différence est que le générateur produit maintenant un signal
<em>carré</em> d’amplitude 5 V et de fréquence 222 Hz. Cela signifie que ce signal
est égal à 5 V pendant la moitié de sa période, et à 0 V pendant l’autre
moitié.</p>
<p>Les modifications à apporter à votre code pour remplacer le signal sinusoïdal
par ce signal carré devraient être minimales. (En particulier, le calcul des
valeurs de <span class="math">\(I\)</span> et de <span class="math">\(P\)</span> devraient rester inchangés.) Le programme
fournit-il le résultat attendu? Si oui, déposez-le dans le répertoire centralisé,
avec le suffixe <code class="docutils literal"><span class="pre">prog-6.py</span></code>.</p>
</div>
<div class="section" id="programmes-7-et-8-circuit-rc">
<h2>Programmes 7 et 8: Circuit RC<a class="headerlink" href="#programmes-7-et-8-circuit-rc" title="Lien permanent vers ce titre">¶</a></h2>
<p>Dans cette dernière étape, nous étudierons un <em>circuit RC</em>, faisant intervenir
une résistance et un condensateur. Son schéma est le suivant:</p>
<blockquote>
<div><div class="figure align-center" id="id10">
<a class="reference internal image-reference" href="_images/circuit-rc-square.png"><img alt="Circuit RC." src="_images/circuit-rc-square.png" style="width: 509.0px; height: 287.0px;" /></a>
<p class="caption"><span class="caption-text">Circuit RC.</span></p>
</div>
</div></blockquote>
<p>Nous nous intéressons à quatre signaux:</p>
<ul class="simple">
<li>La tension <span class="math">\(V_1\)</span> produite par le générateur, qui prend comme pour le
programme 6 la forme d’un signal carré de fréquence 222 Hz.</li>
<li>La tension <span class="math">\(V_2\)</span> aux bornes du condensateur.</li>
<li>Le courant <span class="math">\(I\)</span> traversant la résistance et le condensateur
(mesuré par l’ampèremètre “A”).</li>
<li>La puissance <span class="math">\(P\)</span> échangée avec le condensateur.</li>
</ul>
<p>Les modifications à apporter au programme 6 sont les suivantes
(effectuez-les dans un nouveau programme <code class="docutils literal"><span class="pre">prog-7.py</span></code>). Dans la
fonction <code class="docutils literal"><span class="pre">generer_signaux()</span></code>:</p>
<ul>
<li><p class="first">La tension <span class="math">\(V_1\)</span> est générée de la même façon que la tension
<span class="math">\(V\)</span> dans le programme 6.</p>
</li>
<li><p class="first">La tension <span class="math">\(V_2\)</span> dépend du niveau de charge du condensateur.
Le plus simple consiste à représenter cette tension par une nouvelle
variable globale <code class="docutils literal"><span class="pre">tension_condensateur</span></code> qui sera gérée par la fonction
<code class="docutils literal"><span class="pre">generer_signaux()</span></code>. Initialement, on peut considérer que cette tension
est nulle (c’est-à-dire, que le condensateur est déchargé au début de la
simulation).</p>
</li>
<li><p class="first">A partir de <span class="math">\(V_1\)</span> et de <span class="math">\(V_2\)</span>, le courant <span class="math">\(I\)</span> peut
se calculer en appliquant la loi d’Ohm aux bornes de la résistance:</p>
<blockquote>
<div><div class="math">
\[I = \frac{V_1 - V_2}{R}.\]</div>
</div></blockquote>
</li>
<li><p class="first">La valeur du courant <span class="math">\(I\)</span> permet de mettre à jour la tension du
condensateur, celui-ci se chargeant si <span class="math">\(I\)</span> est positif et se
déchargeant s’il est négatif; Pendant le pas de temps <span class="math">\(\textit{dt}\)</span>
de la simulation, la tension <span class="math">\(V_2\)</span> (mémorisée dans
<code class="docutils literal"><span class="pre">tension_condensateur</span></code>) doit évoluer selon la loi:</p>
<blockquote>
<div><div class="math">
\[V_2 \,\leftarrow\, V_2 + \frac{I\textit{dt}}{C}.\]</div>
</div></blockquote>
</li>
<li><p class="first">La puissance échangée avec le condensateur est donnée par le produit</p>
<blockquote>
<div><div class="math">
\[P = V_2 \times I.\]</div>
</div></blockquote>
</li>
</ul>
<p><strong>Note importante:</strong> Pour que les signaux 3 et 4 soient visibles,
vous devez modifier le gain qui leur est appliqué dans le
programme. Pour les valeurs proposées des composants, un gain de
20000 pour ces deux signaux produit un bon résultat.</p>
<p>Après avoir implémenté ces modifications dans votre programme,
qu’observez-vous? N’hésitez pas à expérimenter en modifiant
la valeur de R et de C. Les signaux obtenus correspondent-ils à ce que
prévoit la théorie?</p>
<p>Une fois que votre programme est au point,
déposez-le dans le répertoire des laboratoires, avec le suffixe
<code class="docutils literal"><span class="pre">prog-7.py</span></code>.</p>
<p>Il reste à présent à simuler le même circuit, mais avec un générateur
sinusoïdal:</p>
<blockquote>
<div><div class="figure align-center" id="id11">
<a class="reference internal image-reference" href="_images/circuit-rc-sin.png"><img alt="Circuit RC avec signal sinusoïdal." src="_images/circuit-rc-sin.png" style="width: 509.0px; height: 287.0px;" /></a>
<p class="caption"><span class="caption-text">Circuit RC avec signal sinusoïdal.</span></p>
</div>
</div></blockquote>
<p>Les modifications à apporter au programme sont simples. Cette fois,
avant de les effectuer et de tester l’application, essayez de dessiner
sur une feuille de papier la forme des quatre signaux qui devraient être
obtenus. Comparez ensuite vos prédictions avec le résultat de l’expérience.
Déposez enfin votre programme dans le répertoire centralisé, avec le
suffixe <code class="docutils literal"><span class="pre">prog-8.py</span></code>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table des Matières</a></h3>
  <ul>
<li><a class="reference internal" href="#">Laboratoire 3</a><ul>
<li><a class="reference internal" href="#programme-4-l-oscilloscope">Programme 4: L’oscilloscope</a><ul>
<li><a class="reference internal" href="#principes-de-fonctionnement">Principes de fonctionnement</a></li>
<li><a class="reference internal" href="#programme-de-base">Programme de base</a></li>
<li><a class="reference internal" href="#echantillonnage-du-signal">Échantillonnage du signal</a></li>
<li><a class="reference internal" href="#le-declenchement">Le déclenchement</a></li>
<li><a class="reference internal" href="#le-declenchement-reglable">Le déclenchement réglable</a></li>
</ul>
</li>
<li><a class="reference internal" href="#programmes-5-et-6-la-loi-d-ohm">Programmes 5 et 6: La loi d’Ohm</a></li>
<li><a class="reference internal" href="#programmes-7-et-8-circuit-rc">Programmes 7 et 8: Circuit RC</a></li>
</ul>
</li>
</ul>

  <h4>Sujet précédent</h4>
  <p class="topless"><a href="labo2.html"
                        title="Chapitre précédent">Laboratoire 2</a></p>
  <h4>Sujet suivant</h4>
  <p class="topless"><a href="labo4.html"
                        title="Chapitre suivant">Laboratoire 4</a></p>
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/labo3.rst.txt"
            rel="nofollow">Montrer le code source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Recherche rapide</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Index général"
             >index</a></li>
        <li class="right" >
          <a href="labo4.html" title="Laboratoire 4"
             >suivant</a> |</li>
        <li class="right" >
          <a href="labo2.html" title="Laboratoire 2"
             >précédent</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">documentation Laboratoires de programmation mathématique et physique 2 0.1</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Bernard Boigelot.
      Créé avec <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.5.
    </div>
  </body>
</html>